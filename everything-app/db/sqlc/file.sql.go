// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: file.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getFiles = `-- name: GetFiles :many
SELECT 
    path
FROM 
    file
WHERE 
    -- Filename fuzzy search (using LIKE for approximate matching)
    (name ILIKE '%' || $1 || '%' OR $1 IS NULL)
    
    -- File extension exact match
    AND (extension = $2 OR $2 IS NULL)
    -- File size range search
    AND (size >= $3 OR $3 IS NULL)
    AND (size <= $4 OR $4 IS NULL)
    -- File created_at range search
    AND (created_at >= $5 OR $5 IS NULL)
    AND (created_at <= $6 OR $6 IS NULL)
    -- File modified_At range search
    AND (modified_at >= $7 OR $7 IS NULL)
    AND (modified_at <= $8 OR $8 IS NULL)
    -- File accessed_at range search
    AND (accessed_at >= $9 OR $9 IS NULL)
    AND (accessed_at <= $10 OR $10 IS NULL)
    -- -- File content search
    AND (content ILIKE '%' || $11 || '%' OR $11 IS NULL)
OFFSET $12
LIMIT CASE WHEN $13 = 0 THEN NULL ELSE $12 END
`

type GetFilesParams struct {
	Column1      sql.NullString `json:"column_1"`
	Extension    string         `json:"extension"`
	Size         int64          `json:"size"`
	Size_2       int64          `json:"size_2"`
	CreatedAt    time.Time      `json:"created_at"`
	CreatedAt_2  time.Time      `json:"created_at_2"`
	ModifiedAt   time.Time      `json:"modified_at"`
	ModifiedAt_2 time.Time      `json:"modified_at_2"`
	AccessedAt   time.Time      `json:"accessed_at"`
	AccessedAt_2 time.Time      `json:"accessed_at_2"`
	Column11     sql.NullString `json:"column_11"`
	Offset       int32          `json:"offset"`
	Column13     interface{}    `json:"column_13"`
}

// If limit is not provided, return all results
func (q *Queries) GetFiles(ctx context.Context, arg GetFilesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFiles,
		arg.Column1,
		arg.Extension,
		arg.Size,
		arg.Size_2,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.ModifiedAt,
		arg.ModifiedAt_2,
		arg.AccessedAt,
		arg.AccessedAt_2,
		arg.Column11,
		arg.Offset,
		arg.Column13,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFile = `-- name: InsertFile :one
INSERT INTO file (
  name,
  extension,
  size,
  path,
  attributes,
  content,
  created_at,
  modified_at,
  accessed_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, extension, size, path, created_at, modified_at, accessed_at, attributes, content
`

type InsertFileParams struct {
	Name       string    `json:"name"`
	Extension  string    `json:"extension"`
	Size       int64     `json:"size"`
	Path       string    `json:"path"`
	Attributes string    `json:"attributes"`
	Content    string    `json:"content"`
	CreatedAt  time.Time `json:"created_at"`
	ModifiedAt time.Time `json:"modified_at"`
	AccessedAt time.Time `json:"accessed_at"`
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.Name,
		arg.Extension,
		arg.Size,
		arg.Path,
		arg.Attributes,
		arg.Content,
		arg.CreatedAt,
		arg.ModifiedAt,
		arg.AccessedAt,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Extension,
		&i.Size,
		&i.Path,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.AccessedAt,
		&i.Attributes,
		&i.Content,
	)
	return i, err
}
